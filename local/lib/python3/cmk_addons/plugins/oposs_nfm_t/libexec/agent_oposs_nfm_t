#!/usr/bin/env python3	
# Copyright (C) 2025 OETIIKER+PARTNER AG â€“ License: GNU General Public License v2

"""
Special agent for monitoring NFM-T managed Nodes Check_MK.
"""

import argparse
import logging
import sys
import traceback
import os
import json
import base64
import urllib.parse  # Use standard library's urllib.parse for URL encoding
import requests
from cmk.utils.password_store import replace_passwords
from pprint import pprint
import re
from datetime import datetime
import time
import socket

LOGGER = logging.getLogger(__name__)

# Define error states for Check_MK output
CHECK_MK_OK = 0
CHECK_MK_WARN = 1
CHECK_MK_CRIT = 2
CHECK_MK_UNKNOWN = 3

# Constants for retry logic
MAX_RETRIES = 3
RETRY_DELAY = 2  # seconds between retries


def parse_arguments(argv):
    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument("-u", "--username", required=True, type=str, help="user name")
    parser.add_argument(
        "-p", "--password", required=True, type=str, help="user password"
    )
    # Add port parameter
    parser.add_argument(
        "--port", type=int, default=443, help="Port number (default: 443)"
    )
    parser.add_argument(
        "--no-cert-check", action="store_true", help="Disable SSL certificate verification (insecure)"
    )
    parser.add_argument(
        "-d", "--debug", action="store_true", help="Debug mode: raise Python exceptions"
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        help="Be more verbose (use twice for even more)",
    )
    parser.add_argument(
        "-r",
        "--retries",
        type=int,
        default=MAX_RETRIES,
        help=f"Number of connection retries (default: {MAX_RETRIES})",
    )
    parser.add_argument("hostaddress", help="nfm_t host name")

    args = parser.parse_args(argv)

    if args.verbose and args.verbose >= 2:
        fmt = "%(asctime)s %(levelname)s: %(name)s: %(filename)s: Line %(lineno)s %(message)s"
        lvl = logging.DEBUG
    elif args.verbose:
        fmt = "%(asctime)s %(levelname)s: %(message)s"
        lvl = logging.INFO
    else:
        fmt = "%(asctime)s %(levelname)s: %(message)s"
        lvl = logging.WARNING

    if args.debug:
        lvl = logging.DEBUG

    logging.basicConfig(level=lvl, format=fmt)

    return args


class NFMTConnectionError(Exception):
    """Custom exception for connection-related errors with NFM-T"""
    pass


class NFMTAuthenticationError(Exception):
    """Custom exception for authentication-related errors with NFM-T"""
    pass


class NFMTAPIError(Exception):
    """Custom exception for API response-related errors with NFM-T"""
    pass


class NFMTDataError(Exception):
    """Custom exception for data processing errors with NFM-T"""
    pass


class nfmTFetcher:
    def __init__(self, hostaddress, username, password, max_retries=MAX_RETRIES, port=443, no_cert_check=False) -> None:  # type:ignore[no-untyped-def]
        # Use the provided port in the endpoint
        self._endpoint = "https://%s:%d/" % (hostaddress, port)
        self._testmode = hostaddress == "test"
        self._max_retries = max_retries
        self._headers = None
        self._access_token = None
        self._username = username
        self._password = password
        self._verify_ssl = not no_cert_check
        
        if self._testmode:
            LOGGER.info("Running in test mode with host 'test'")
            return
        
        # Verify DNS resolution before attempting connection
        try:
            socket.gethostbyname(hostaddress)
        except socket.gaierror as e:
            LOGGER.error(f"DNS resolution failed for host '{hostaddress}': {e}")
            raise NFMTConnectionError(f"DNS resolution failed for host '{hostaddress}': {e}")
        
        self._authenticate(username, password)

    def _authenticate(self, username, password):
        """Handle authentication with retry logic"""
        auth_endpoint = self._endpoint + "rest-gateway/rest/api/v1/auth/token"
        auth_headers = {
            "content-type": "application/json",
            "accept": "application/json",
            "authorization": "Basic %s" % base64.b64encode(
                    f"{username}:{password}".encode("utf-8")
                ).decode("utf-8"),
        }
        
        for retry in range(self._max_retries):
            try:
                LOGGER.debug(f"Attempting authentication to {auth_endpoint}, attempt {retry+1}/{self._max_retries}")
                response = requests.post(
                    auth_endpoint,
                    headers=auth_headers,
                    json={"grant_type": "client_credentials"},
                    verify=self._verify_ssl,
                    timeout=30,  # Add timeout to prevent hanging
                )
                
                if response.status_code == 401:
                    LOGGER.error(f"Authentication failed with status code {response.status_code}")
                    raise NFMTAuthenticationError(f"Authentication failed: Invalid credentials")
                
                if response.status_code != 200:
                    LOGGER.error(f"Authentication failed with status code {response.status_code}: {response.text}")
                    raise NFMTAPIError(f"Authentication failed with status code {response.status_code}")
                
                self._access_token = response.json().get("access_token")
                if not self._access_token:
                    LOGGER.error("No access token in authentication response")
                    raise NFMTAPIError("No access token in authentication response")
                
                self._headers = {
                    "content-type": "application/json",
                    "accept": "application/json",
                    "authorization": "Bearer %s" % self._access_token,
                }
                LOGGER.debug("Authentication successful")
                return
                
            except requests.ConnectionError as e:
                LOGGER.warning(f"Connection error during authentication (attempt {retry+1}/{self._max_retries}): {e}")
                if retry < self._max_retries - 1:
                    LOGGER.info(f"Retrying in {RETRY_DELAY} seconds...")
                    time.sleep(RETRY_DELAY)
                else:
                    LOGGER.error(f"Failed to connect after {self._max_retries} attempts")
                    raise NFMTConnectionError(f"Failed to connect to {self._endpoint}: {e}")
            
            except requests.Timeout as e:
                LOGGER.warning(f"Timeout during authentication (attempt {retry+1}/{self._max_retries}): {e}")
                if retry < self._max_retries - 1:
                    LOGGER.info(f"Retrying in {RETRY_DELAY} seconds...")
                    time.sleep(RETRY_DELAY)
                else:
                    LOGGER.error(f"Connection timed out after {self._max_retries} attempts")
                    raise NFMTConnectionError(f"Connection timed out: {e}")
            
            except (requests.RequestException, json.JSONDecodeError) as e:
                LOGGER.error(f"Error during authentication: {e}")
                raise NFMTAPIError(f"Error during authentication: {e}")
            
    def _revoke_token(self):
        """Revoke the access token when done"""
        # Check if we're in test mode or if the token attribute doesn't exist or is None
        if getattr(self, '_testmode', True) or self._access_token is None:
            return

        # Correct endpoint path based on the documentation
        revoke_endpoint = self._endpoint + "rest-gateway/rest/api/v1/auth/revocation"
        
        # Create form data with the token
        form_data = {
            "token": self._access_token,
            "token_type_hint": "token",  # Based on the API doc
            "formVars": json.dumps({})  # Empty JSON object as formVars
        }
        
        # Set proper headers for form URL encoded data
        revoke_headers = {
            "authorization": "Basic %s" % base64.b64encode(
                    f"{self._username}:{self._password}".encode("utf-8")
                ).decode("utf-8"),
            "content-type": "application/x-www-form-urlencoded",
        }
        
        try:
            LOGGER.debug(f"Revoking token at {revoke_endpoint}")
            response = requests.post(
                revoke_endpoint,
                headers=revoke_headers,
                data=form_data,
                verify=self._verify_ssl,
                timeout=30,
            )
            
            if response.status_code == 200:
                LOGGER.debug("Token successfully revoked")
            else:
                LOGGER.warning(f"Failed to revoke token: {response.status_code} - {response.text}")
                
        except Exception as e:
            # Don't raise exceptions during cleanup - just log them
            LOGGER.warning(f"Error during token revocation: {e}")
        
        # Clear token and headers regardless of success
        self._access_token = None
        self._headers = None    

    def _make_api_request(self, method, endpoint, params=None):
        """Make API request with retry logic"""
        if self._testmode:
            # Map endpoints to specific test files
            if endpoint.endswith("alarms/details"):
                test_file = "/tmp/nfm_t_alarms.json"
            elif endpoint.endswith("otn/node/"):
                test_file = "/tmp/nfm_t_nodes.json"
            elif endpoint.endswith("otn/connection/path"):
                test_file = "/tmp/nfm_t_services.json"
            else:
                test_file = f"/tmp/nfm_t_{endpoint.split('/')[-1]}.json"
                
            LOGGER.debug(f"Test mode: Loading test data from {test_file}")
            try:
                return json.load(open(test_file))
            except (FileNotFoundError, json.JSONDecodeError) as e:
                LOGGER.error(f"Error loading test data: {e}")
                raise NFMTDataError(f"Error loading test data from {test_file}: {e}")
        
        if not self._headers:
            raise NFMTAuthenticationError("Not authenticated. Headers not initialized.")
        
        full_url = f"{self._endpoint}{endpoint}"
        for retry in range(self._max_retries):
            try:
                LOGGER.debug(f"Making {method} request to {full_url}, attempt {retry+1}/{self._max_retries}")
                response = requests.request(
                    method=method,
                    url=full_url,
                    headers=self._headers,
                    params=params,
                    verify=self._verify_ssl,
                    timeout=60,  # Add timeout to prevent hanging
                )
                
                if response.status_code != 200:
                    LOGGER.warning(f"API request failed with status code: {response.status_code}")
                    LOGGER.warning(f"Response: {response.text}")
                    raise NFMTAPIError(f"API request to {full_url} failed with status code {response.status_code}: {response.text}")
                
                try:
                    return response.json()
                except json.JSONDecodeError as e:
                    LOGGER.error(f"Failed to decode JSON response: {e}")
                    LOGGER.debug(f"Response content: {response.text[:1000]}...")
                    raise NFMTDataError(f"Failed to decode JSON response: {e}")
                
            except requests.ConnectionError as e:
                LOGGER.warning(f"Connection error during API request (attempt {retry+1}/{self._max_retries}): {e}")
                if retry < self._max_retries - 1:
                    LOGGER.info(f"Retrying in {RETRY_DELAY} seconds...")
                    time.sleep(RETRY_DELAY)
                else:
                    LOGGER.error(f"Failed to connect after {self._max_retries} attempts")
                    raise NFMTConnectionError(f"Failed to connect to {full_url}: {e}")
            
            except requests.Timeout as e:
                LOGGER.warning(f"Timeout during API request (attempt {retry+1}/{self._max_retries}): {e}")
                if retry < self._max_retries - 1:
                    LOGGER.info(f"Retrying in {RETRY_DELAY} seconds...")
                    time.sleep(RETRY_DELAY)
                else:
                    LOGGER.error(f"Request timed out after {self._max_retries} attempts")
                    raise NFMTConnectionError(f"Request timed out: {e}")
            
            except requests.RequestException as e:
                LOGGER.error(f"Error during API request: {e}")
                raise NFMTAPIError(f"Error during API request to {full_url}: {e}")

    def __fetch_alarms(self):
        try:
            # In test mode, we don't need to build the filter
            if self._testmode:
                return self._make_api_request("GET", "FaultManagement/rest/api/v2/alarms/details")
                
            severity_levels = ['critical', 'major', 'minor']
            alarm_filter = ' or '.join(f"severity='{level}'" for level in severity_levels)
            encoded_filter = urllib.parse.quote(alarm_filter)
            
            return self._make_api_request(
                "GET", 
                "FaultManagement/rest/api/v2/alarms/details", 
                params={"alarmFilter": encoded_filter}
            )
        except Exception as e:
            LOGGER.error(f"Error fetching alarms: {e}")
            raise NFMTAPIError(f"Failed to fetch alarms: {e}")
        
    def __fetch_nodes(self):
        try:
            return self._make_api_request("GET", "oms1350/data/otn/node/")
        except Exception as e:
            LOGGER.error(f"Error fetching nodes: {e}")
            raise NFMTAPIError(f"Failed to fetch nodes: {e}")
        
    def __fetch_services(self):
        try:
            return self._make_api_request("GET", "oms1350/data/otn/connection/path")
        except Exception as e:
            LOGGER.error(f"Error fetching services: {e}")
            raise NFMTAPIError(f"Failed to fetch services: {e}")
        
    def fetch(self):
        """Fetch data from NFM-T and return processed results"""
        try:
            # Fetch all required data
            alarms_data = self.__fetch_alarms()
            nodes_data = self.__fetch_nodes()
            services_data = self.__fetch_services()
            
            # Process the data
            return self.__postprocess(alarms_data, nodes_data, services_data)
            
        except NFMTConnectionError as e:
            LOGGER.error(f"Connection error: {e}")
            return self.__generate_error_output("CONNECTION_ERROR", str(e))
            
        except NFMTAuthenticationError as e:
            LOGGER.error(f"Authentication error: {e}")
            return self.__generate_error_output("AUTH_ERROR", str(e))
            
        except NFMTAPIError as e:
            LOGGER.error(f"API error: {e}")
            return self.__generate_error_output("API_ERROR", str(e))
            
        except NFMTDataError as e:
            LOGGER.error(f"Data processing error: {e}")
            return self.__generate_error_output("DATA_ERROR", str(e))
            
        except Exception as e:
            LOGGER.error(f"Unexpected error: {e}")
            LOGGER.debug(traceback.format_exc())
            return self.__generate_error_output("UNKNOWN_ERROR", str(e))
        
        finally:
            # Always attempt to revoke the token, regardless of success or failure
            try:
                self._revoke_token()
            except Exception as e:
                LOGGER.warning(f"Error during token revocation in finally block: {e}")

    def __del__(self):
        """Destructor to ensure token is revoked when object is garbage collected"""
        try:
            self._revoke_token()
        except Exception as e:
            # We can't use LOGGER here reliably in __del__ as it might be None during shutdown
            # So we use a direct print statement as a fallback
            try:
                LOGGER.warning(f"Error during cleanup in destructor: {e}")
            except:
                print(f"Warning: Error during token cleanup in destructor: {e}")

    def __generate_error_output(self, error_type, error_message):
        """Generate a properly formatted error output for Check_MK"""
        # Create a standardized error response that the Check_MK plugin can handle
        error_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return [{
            "node": "NFM-T_AGENT",
            "alarms": [{
                "severity": "critical",
                "summary": f"Agent Error [{error_type}]: {error_message} at {error_time}"
            }]
        }]

    def __postprocess(self, alarms, nodes, services):
        """Process the data from NFM-T API into piggyback output format"""
        try:
            SEVERITY_LEVELS = {
                'critical': 4,
                'major': 3,
                'minor': 2,
                'warning': 1,
                'ok': 0
            }

            # Build node alarms dictionary
            node_alarms = {}
            sorted_alarms = sorted(
                alarms.get('response', {}).get('data', []),
                key=lambda x: SEVERITY_LEVELS.get(x.get('severity', 'ok'), 0),
                reverse=True
            )

            for alarm in sorted_alarms:
                ne_name = alarm.get('neName')
                if not ne_name:
                    LOGGER.warning(f"Alarm without neName: {alarm}")
                    continue

                current_severity = alarm.get('severity', 'ok').lower()

                if ne_name not in node_alarms:
                    node_alarms[ne_name] = []

                node_alarms[ne_name].append({
                    'summary': alarm.get('additionalText', 'No additional text'),
                    'severity': current_severity
                })

            # Build services dictionary per node (services appear on both endpoints)
            node_services = {}
            for service in services.get('items', []):
                service_id = service.get('id')
                if not service_id:
                    LOGGER.warning(f"Service without id: {service}")
                    continue

                # Extract relevant fields for the service
                service_data = {
                    'id': service_id,
                    'guiLabel': service.get('guiLabel', ''),
                    'operationalState': service.get('operationalState', ''),
                    'alarmState': service.get('alarmState', 'Cleared'),
                    'alarmSeverity': service.get('alarmSeverity', 'Cleared'),
                    'aPortLabel': service.get('aPortLabel', ''),
                    'zPortLabel': service.get('zPortLabel', ''),
                    'effectiveRate': service.get('effectiveRate', ''),
                    'a1NodeName': service.get('a1NodeName', ''),
                    'z1NodeName': service.get('z1NodeName', ''),
                }

                # Add service to a-side node
                a_node = service.get('a1NodeName')
                if a_node:
                    if a_node not in node_services:
                        node_services[a_node] = []
                    node_services[a_node].append({**service_data, 'role': 'a'})

                # Add service to z-side node
                z_node = service.get('z1NodeName')
                if z_node:
                    if z_node not in node_services:
                        node_services[z_node] = []
                    node_services[z_node].append({**service_data, 'role': 'z'})

            # Collect all known node names
            known_nodes = set()
            for node in nodes.get('items', []):
                if node.get('guiLabel'):
                    known_nodes.add(node['guiLabel'])

            # Find unassigned alarms (alarms for nodes not in the node list, e.g., MNC-FM)
            unassigned_alarms = []
            for ne_name, alarms_list in node_alarms.items():
                if ne_name not in known_nodes:
                    for alarm in alarms_list:
                        alarm['neName'] = ne_name  # Include the source name
                        unassigned_alarms.append(alarm)

            # Build result structure
            result = {
                'agent_status': {
                    'status': 'ok',
                    'node_count': len(nodes.get('items', []))
                },
                'unassigned_alarms': unassigned_alarms,
                'nodes': {}
            }

            for node in nodes.get('items', []):
                node_name = node.get('guiLabel')
                if not node_name:
                    LOGGER.warning(f"Node without guiLabel: {node}")
                    continue

                # Get alarms for this node (default to "ok" if none)
                alarms_list = node_alarms.get(node_name, [])
                if not alarms_list:
                    alarms_list = [{'severity': 'ok', 'summary': 'No active Alarms'}]

                # Get services for this node
                services_list = node_services.get(node_name, [])

                result['nodes'][node_name] = {
                    'alarms': alarms_list,
                    'services': services_list
                }

            if not result['nodes']:
                LOGGER.warning("No nodes found in the processed data")
                return self.__generate_error_output("NO_NODES", "No nodes found in the API response")

            return result

        except Exception as e:
            LOGGER.error(f"Error in postprocessing: {e}")
            LOGGER.debug(traceback.format_exc())
            raise NFMTDataError(f"Failed to process data: {e}")


def output_piggyback(data):
    """Output data in CheckMK piggyback format"""
    # Output agent status section (for the NFM-T host itself)
    # Include unassigned alarms (e.g., MNC-FM system alarms)
    agent_data = {
        **data['agent_status'],
        'unassigned_alarms': data.get('unassigned_alarms', [])
    }
    sys.stdout.write("<<<oposs_nfm_t:sep(0)>>>\n")
    sys.stdout.write(json.dumps(agent_data, sort_keys=True, separators=(',', ':')) + "\n")

    # Output piggyback sections for each node
    for node_name, node_data in data['nodes'].items():
        # Start piggyback section for this node
        sys.stdout.write(f"<<<<{node_name}>>>>\n")

        # Output node alarms section
        sys.stdout.write("<<<oposs_nfm_t_node:sep(0)>>>\n")
        sys.stdout.write(json.dumps({'alarms': node_data['alarms']}, sort_keys=True, separators=(',', ':')) + "\n")

        # Output services section (one JSON line per service)
        sys.stdout.write("<<<oposs_nfm_t_service:sep(0)>>>\n")
        for service in node_data['services']:
            sys.stdout.write(json.dumps(service, sort_keys=True, separators=(',', ':')) + "\n")

        # End piggyback section
        sys.stdout.write("<<<<>>>>\n")


def output_error(error_type, error_message):
    """Output error in CheckMK format"""
    sys.stdout.write("<<<oposs_nfm_t:sep(0)>>>\n")
    sys.stdout.write(json.dumps({
        "status": "error",
        "error_type": error_type,
        "error_message": str(error_message)
    }, sort_keys=True, separators=(',', ':')) + "\n")


def main(argv=None):
    args = None
    try:
        replace_passwords()
        args = parse_arguments(argv or sys.argv[1:])

        # Disable SSL warnings if certificate verification is disabled
        if args.no_cert_check:
            requests.packages.urllib3.disable_warnings()

        # Initialize fetcher with retry count, port, and cert check from args
        fetcher = nfmTFetcher(args.hostaddress, args.username, args.password, args.retries, args.port, args.no_cert_check)

        # Fetch data
        data = fetcher.fetch()

        # Check if we got an error response (legacy format from __generate_error_output)
        if isinstance(data, list):
            # Legacy error format - convert to new format
            output_error("FETCH_ERROR", data[0].get('alarms', [{}])[0].get('summary', 'Unknown error'))
            sys.exit(CHECK_MK_CRIT)

        # Output in piggyback format
        output_piggyback(data)
        sys.exit(CHECK_MK_OK)

    except NFMTConnectionError as e:
        LOGGER.error(f"Connection error: {e}")
        if args and args.debug:
            sys.stderr.write(traceback.format_exc())
        output_error("CONNECTION_ERROR", e)
        sys.exit(CHECK_MK_CRIT)

    except NFMTAuthenticationError as e:
        LOGGER.error(f"Authentication error: {e}")
        if args and args.debug:
            sys.stderr.write(traceback.format_exc())
        output_error("AUTH_ERROR", e)
        sys.exit(CHECK_MK_CRIT)

    except (NFMTAPIError, NFMTDataError) as e:
        LOGGER.error(f"API or data error: {e}")
        if args and args.debug:
            sys.stderr.write(traceback.format_exc())
        output_error("API_ERROR", e)
        sys.exit(CHECK_MK_CRIT)

    except Exception as e:
        LOGGER.error(f"Unexpected error: {e}")
        if args and args.debug:
            sys.stderr.write(traceback.format_exc())
        output_error("UNKNOWN_ERROR", e)
        sys.exit(CHECK_MK_UNKNOWN)


if __name__ == "__main__":
    main()